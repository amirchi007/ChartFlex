package com.amir.steelsenseandroidtask.uiimport androidx.compose.animation.core.Animatableimport androidx.compose.animation.core.tweenimport androidx.compose.runtime.Composableimport androidx.compose.foundation.Canvasimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.gestures.detectTapGesturesimport androidx.compose.foundation.gestures.detectTransformGesturesimport androidx.compose.foundation.layout.Arrangementimport androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.Rowimport androidx.compose.foundation.layout.Spacerimport androidx.compose.foundation.layout.aspectRatioimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.fillMaxWidthimport androidx.compose.foundation.layout.widthimport androidx.compose.material3.Buttonimport androidx.compose.material3.Textimport androidx.compose.runtime.LaunchedEffectimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableFloatStateOfimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.geometry.Offsetimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.graphics.StrokeCapimport androidx.compose.ui.graphics.drawscope.Strokeimport androidx.compose.ui.graphics.drawscope.clipRectimport androidx.compose.ui.graphics.nativeCanvasimport androidx.compose.ui.graphics.toArgbimport androidx.compose.ui.input.pointer.pointerInputimport androidx.compose.ui.layout.onGloballyPositionedimport androidx.compose.ui.unit.dpimport com.amir.steelsenseandroidtask.domain.model.ChartEntryimport kotlin.math.roundToInt@Composablefun LineChartCanvas(    datasets: List<Pair<List<ChartEntry>, Color>>,    modifier: Modifier = Modifier) {    var scaleX by remember { mutableFloatStateOf(1f) }    var offsetX by remember { mutableFloatStateOf(0f) }    var holdPosition by remember { mutableStateOf<Offset?>(null) }    val minScale = 1f    val maxScale = 5f    val animOffsetX = remember { Animatable(0f) }    var chartWidthPx by remember { mutableFloatStateOf(0f) }    LaunchedEffect(offsetX) {        animOffsetX.animateTo(offsetX, animationSpec = tween(durationMillis = 300))    }    Column(horizontalAlignment = Alignment.CenterHorizontally) {        Box(            modifier = modifier                .aspectRatio(1f)                .background(Color.White)        ) {            Canvas(                modifier = Modifier                    .fillMaxSize()                    .pointerInput(Unit) {                        detectTransformGestures { _, pan, zoom, _ ->                            val newScale = (scaleX * zoom).coerceIn(minScale, maxScale)                            val totalWidth = size.width * newScale                            val newOffsetX = (offsetX + pan.x).coerceIn(-(totalWidth - size.width), 0f)                            scaleX = newScale                            offsetX = newOffsetX                        }                    }                    .pointerInput(Unit) {                        detectTapGestures(                            onPress = { offset ->                                holdPosition = offset                                tryAwaitRelease()                                holdPosition = null                            }                        )                    }                    .onGloballyPositioned { coordinates ->                        chartWidthPx = coordinates.size.width.toFloat()                    }            ) {                val allEntries = datasets.flatMap { it.first }                val maxX = allEntries.maxOfOrNull { it.time }?.let { it + it * 0.001f } ?: 1f                val maxY = allEntries.maxOfOrNull { it.value } ?: 1f                val padding = 20.dp.toPx()                val leftPadding = 40.dp.toPx()                val chartWidth = size.width - leftPadding - padding                val chartHeight = size.height - 2 * padding                val totalDataWidth = chartWidth * scaleX                val minOffsetX = -(totalDataWidth - chartWidth)                offsetX = offsetX.coerceIn(minOffsetX, 0f)                // back ground grids y                for (i in 0..5) {                    val y = padding + i * (chartHeight / 5)                    drawLine(Color.LightGray, Offset(leftPadding, y), Offset(size.width - padding, y), 1.dp.toPx())                }                // back ground grids x                val gridLines = 6                for (i in 0..gridLines) {                    val x = leftPadding + i * (chartWidth / gridLines)                    drawLine(Color.LightGray, Offset(x, padding), Offset(x, size.height - padding), 1.dp.toPx())                }                // main graph                drawLine(Color.Gray, Offset(leftPadding, size.height - padding), Offset(size.width - padding, size.height - padding), 3f)                drawLine(Color.Gray, Offset(leftPadding, padding), Offset(leftPadding, size.height - padding), 3f)                // Y label                val yLabels = listOf("morn", "noon", "night")                yLabels.forEachIndexed { i, label ->                    val y = padding + i * (chartHeight / 2)                    drawContext.canvas.nativeCanvas.drawText(                        label, 10f, y - 10f,                        android.graphics.Paint().apply {                            color = android.graphics.Color.BLACK                            textSize = 32f                        }                    )                }                // X label                val xLabels = listOf(0, 500, 1000)                xLabels.forEachIndexed { i, label ->                    val x = leftPadding + i * (chartWidth / (xLabels.size - 1))                    drawContext.canvas.nativeCanvas.drawText(                        "$label", x + 5, size.height - 10,                        android.graphics.Paint().apply {                            color = android.graphics.Color.BLACK                            textSize = 32f                        }                    )                }                //  creating graph                val clipRight = leftPadding + chartWidth                clipRect(left = leftPadding, top = padding, right = clipRight, bottom = size.height - padding) {                    datasets.forEach { (data, color) ->                        val points = data.map {                            Offset(                                x = leftPadding + (it.time / maxX) * totalDataWidth + offsetX,                                y = size.height - padding - (it.value / maxY) * chartHeight                            )                        }                        if (points.size >= 2) {                            val areaPath = androidx.compose.ui.graphics.Path().apply {                                moveTo(points.first().x, size.height - padding)                                points.forEach { lineTo(it.x, it.y) }                                lineTo(points.last().x, size.height - padding)                                close()                            }                            drawPath(areaPath, color.copy(alpha = 0.2f))                        }                        if (points.size >= 2) {                            val path = androidx.compose.ui.graphics.Path(   ).apply {                                moveTo(points.first().x, points.first().y)                                for (i in 1 until points.size) lineTo(points[i].x, points[i].y)                            }                            drawPath(path, color, style = Stroke(width = 4.dp.toPx(), cap = StrokeCap.Round))                        }                        points.forEach { point ->                            drawCircle(color = Color.Black, radius = 6.dp.toPx(), center = point)                        }                    }                }                // pointer                if (datasets.isNotEmpty()) {                    holdPosition?.let { pos ->                        val clampedX = pos.x.coerceIn(leftPadding, size.width - padding)                        drawLine(Color.Gray, Offset(clampedX, padding), Offset(clampedX, size.height - padding), 2.dp.toPx())                        val chartX = (clampedX - leftPadding - animOffsetX.value) / (chartWidth * scaleX) * maxX                        val index = chartX.roundToInt().coerceIn(0, datasets.first().first.size - 1)                        datasets.forEachIndexed { i, (data, color) ->                            val value = data.getOrNull(index)?.value ?: return@forEachIndexed                            val time = data.getOrNull(index)?.time ?: return@forEachIndexed                            drawContext.canvas.nativeCanvas.drawText(                                "line ${i + 1}: ${value.toInt()} step per hour ${time.toInt()}",                                leftPadding + 100,                                padding - 200 + i * 55f,                                android.graphics.Paint().apply {                                    this.color = color.toArgb()                                    textSize = 46f                                }                            )                        }                    }                }            }        }        Row(            modifier = Modifier                .fillMaxWidth(),            horizontalArrangement = Arrangement.SpaceEvenly        ) {            Button(                onClick = { offsetX = 0f },                modifier = Modifier.weight(1f)            ) {                Text("first")            }            Spacer(modifier = Modifier.width(8.dp))            Button(                onClick = {                    val totalWidth = chartWidthPx * scaleX                    offsetX = -(totalWidth - chartWidthPx)                },                modifier = Modifier.weight(1f)            ) {                Text("End")            }        }    }}